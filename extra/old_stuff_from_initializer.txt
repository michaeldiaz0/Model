#if 0
			//mult = (s-(double)k/d);
			//ivort[i][low_lat-7][k+fi] = 0.25e-5 * (s-(double)k/d)*mult;
			//ivort[i][low_lat-6][k+fi] = 0.25e-5 * (s-(double)k/d)*mult;

			ivort[i][low_lat-5][k+fi] = 0.25e-5 * mult;
			ivort[i][low_lat-4][k+fi] = 0.5e-5 * mult;
			ivort[i][low_lat-3][k+fi] = 0.75e-5 * mult;		
			ivort[i][low_lat-2][k+fi] = 2e-5 * mult;
			ivort[i][low_lat-1][k+fi] = 4.0e-5 * mult;
			ivort[i][low_lat][k+fi] = 6.0e-5 * mult;
			ivort[i][low_lat+1][k+fi] = 4.0e-5 * mult;
			ivort[i][low_lat+2][k+fi] = 2e-5 * mult;
			ivort[i][low_lat+3][k+fi] = 0.75e-5 * mult;
			//ivort[i][low_lat+4][k+fi] = 0.5e-5 * mult;
			
			ivort[i][low_lat+5-1][k+fi] = -0.25e-5 * mult;
			
			//ivort[i][low_lat+6][k+fi] = 0.25e-5 * (s-(double)k/d)*mult;
			//ivort[i][low_lat+7][k+fi] = 0.25e-5 * (s-(double)k/d)*mult;			
			
			
			ivort[i][low_lat+6-1][k+fi] = -1.0e-5 * mult;
			ivort[i][low_lat+7-1][k+fi] = -3.0e-5* mult;
			ivort[i][low_lat+8-1][k+fi] = -2.0e-5* mult;
			ivort[i][low_lat+9-1][k+fi] = -1e-5* mult;
#endif			
		//}

		//}
	/*
	
	for(int i=low_lon;i<high_lon;i++){
		
		for(int k=0;k<11;k++){

			ivort[i][low_lat][k] *= (0.5 + (double)k/(2.*11));
		}

	}
	*/
	
	//}


#if 0

//			printf("%lu %lu %lu %f %f %f\n",xdim,ydim,zdim,grid_spacing[0],grid_spacing[1],grid_spacing[2]);
	
//			for(int i=0;i<zdim;i++){ printf("%f\n",zlevs[i]);}
		}
			//get_data_at_time(myfilename,"u-wind",time,var,xdim,ydim,zdim);
			
			//horz_interpolate_from_model(double *uz,double *out,int xdim,int ydim,int zdim,bool xstagger,bool ystagger,double dlat,double dlon,double lonoffset,double latoffset)
			
			//vert_interpolate_1d_from_model(zsu, zlevs, var, xdim,ydim,zdim,NZ,var_interpz);
			
			//horz_interpolate_from_model(var_interpz,iubar,xdim,ydim,NZ,false,false,grid_spacing[0]/meters_per_degree,grid_spacing[1]/meters_per_degree,myLons[0]-outLons[0],myLats[0]-outLats[0]);

			for(int i=0;i<xdim;i++){
			for(int j=0;j<ydim;j++){
	
				for(int k=0;k<zdim;k++){
				
					if(j==ydim/2 && i==xdim/2){
				
						printf("%d %f %f\n",k,zlevs[k],var[k+j*zdim+i*zdim*ydim]);
					}
				}
				
				for(int k=0;k<NZ;k++){
				
					if(j==ydim/2 && i==xdim/2){
				
						printf("%d %f %f\n",k,zsu[k],var_interpz[k+j*NZ+i*NZ*ydim]);
					}
				}
			}}
#endif

#if 0
		for(int t=0;t<10;t++){
		
			for(int i=0;i<NX;i++){
			for(int j=3;j<NY-3;j++){
			for(int k=0;k<NZ;k++){
		
				IVBAR(i,j,k) = 0.01*diffuse_j_6th(&IUBAR(0,0,0),i,j,k);
			}}}
		
			for(int i=0;i<NX;i++){
			for(int j=3;j<NY-3;j++){
			for(int k=0;k<NZ;k++){
		
				IUBAR(i,j,k) += IVBAR(i,j,k);
			}}}
			
			for(int i=0;i<NX;i++){
			for(int j=3;j<NY-3;j++){
			for(int k=0;k<NZ;k++){
		
				IVBAR(i,j,k) = 0.01*diffuse_j_6th(&ITHBAR(0,0,0),i,j,k);
			}}}
		
			for(int i=0;i<NX;i++){
			for(int j=3;j<NY-3;j++){
			for(int k=0;k<NZ;k++){
		
				ITHBAR(i,j,k) += IVBAR(i,j,k);
			}}}
		}
	
		for(int i=0;i<NX;i++){
		for(int j=3;j<NY-3;j++){
		for(int k=0;k<NZ;k++){
		
			IVBAR(i,j,k) = 0;
		}}}	
		
		for(int j=0;j<NY;j++){
			
			
			
			printf("%f %f\n",IUBAR(NX/2,j,8),ITHBAR(NX/2,j,8));
		}
		#endif
	
#if 0
	//----------------------------------------------------------------
	// Homogenize moisture field
	//----------------------------------------------------------------
	int moisture_lat1 = get_point_from_lat(10);
	int moisture_lat2 = get_point_from_lat(25);
	int moisture_lon1 = get_point_from_lon(75);
	int moisture_lon2 = get_point_from_lon(105);
	
	int moisture_lat0 = get_point_from_lat(22);
	int moisture_lon0 = get_point_from_lon(90);	

	for(int i=moisture_lon1;i<moisture_lon2;i++){
	for(int j=moisture_lat1;j<moisture_lat2;j++){
	for(int k=0;k<NZ;k++){
		
		IQBAR(i,j,k) = IQBAR(moisture_lon0,moisture_lat0,k);
		
	}}}

#endif

#if 0
	for(int i=0;i<NX;i++){
	for(int j=0;j<NY;j++){
	for(int k=0;k<NZ;k++){

		IUBAR(i,j,k) *= 0.5;
		IVBAR(i,j,k) *= 0.5;
		ITHBAR(i,j,k) *= 0.5;
		IQBAR(i,j,k) *= 0.5;//IQBAR(NX/2,NY/2,k);
		IPBAR(i,j,k) = IPBAR(NX/2,NY/2,k);	

	}}}
#endif	


#if 0

/******************************************************************************
*
*
*******************************************************************************/
void initialize_basic_state_idealized(){

	int size = NX*NY*NZ;

	rhoavg = 0;
	mtime = 0;
	bigcounter = 0;
	
	//----------------------------------------------------------------
	// initialize common data
	//----------------------------------------------------------------
	if(PARALLEL)
		memset(&u[0][0][0], 0,NX*NY*NZ*sizeof(double));

	//----------------------------------------------------------------
	// Calculate height of each level
	//----------------------------------------------------------------
	for(int k=0;k<NZ;k++){

		zu[k] = ((double)k-0.5)*dz;
		zw[k] = ((double)k-1)*dz;
	}

	stretched_grid(&zsu[0],&mu[0],&zsw[0],&mw[0],height_lowest_level,index_lowest_level);

	itopo = (double*) calloc(size,sizeof(double));

	//----------------------------------------------------------------
	// initialize data specific to parallel version
	//----------------------------------------------------------------
	#if PARALLEL || ENERGY
	
		ALLOC(iubar,size);
		ALLOC(ivbar,size);
		ALLOC(iwbar,size);
		ALLOC(ithbar,size);
		ALLOC(ipbar,size);
		ALLOC(iqbar,size);
	
		ALLOC(iuistopo,size);
		ALLOC(ivistopo,size);
		ALLOC(iistopo,size);
		ALLOC(ifriction,size);
	
		if(STRETCHED_GRID){initialize_from_era(&zsu[0]);} 
		else {			   initialize_from_era(&zu[0]);}
		
		if(ENERGY){
			
			ALLOC(us,size);
			ALLOC(vs,size);
			ALLOC(ws,size);
			ALLOC(ths,size);
			ALLOC(pis,size);

			//--------------------------------------------------
			// microphysics
			//--------------------------------------------------
			if(USE_MICROPHYSICS){

				ALLOC(qvs,size);
				ALLOC(qcs,size);
				ALLOC(qrs,size);
			}
		}
		
	//----------------------------------------------------------------
	// initialize data specific to serial version
	//----------------------------------------------------------------
	#else
		initialize_flux_cells(NY,NZ);
		initialize_microphysics_cells(NY,NZ);

		initialize_subarray(NX*NY*NZ);

		if(STRETCHED_GRID || IDEAL){ initialize_from_era(&zsu[0]);} 
		else { 				initialize_from_ERA5(&zu[0]);}

		initialize_landsea(landseaMaskFile);

		if(USE_TURBULENT_STRESS){ init_kmix(NX,NY,NZ);}
		if(OUTPUT_DIFFUSION_TEND){ init_damping(NX,NY,NZ);}	
	#endif
		
		
		//----------------------------------------------------------------
		// Initialize stuff for Fourier damping in linearized equations
		//----------------------------------------------------------------
		if(ISLINEAR && FOURIER_DAMPING){
		
			if(!PERIODIC_BOUNDARIES){ init_fftw(NX,NY,NZ);}
			else { init_fftw(NX-6,NY,NZ);}
		}
		

		int base_i = get_point_from_lon(90);
		int base_j = get_point_from_lat(20);

		double full_base_pres[NZ];
		double store_qb[NZ];
		
		for(int k=0;k<NZ;k++){
		
			full_base_pres[k] = IPBAR(base_i,base_j,k);
			//printf("%d %f %f\n",k,zsu[k],full_base_pres[k]);
		}

		for(int i=0;i<NX;i++){
		for(int j=0;j<NY;j++){
		for(int k=0;k<NZ;k++){

			IUBAR(i,j,k) = 0;
			IVBAR(i,j,k) = 0;
			ITHBAR(i,j,k) = ITHBAR(base_i,base_j,k);
			IQBAR(i,j,k) = IQBAR(base_i,base_j,k);
			IPBAR(i,j,k) = 0;//IPBAR(NX/2,NY/2,k);	
		}}}

		for(int i=0;i<NX;i++){
		for(int j=0;j<NY;j++){

			ITHBAR(i,j,0) = ITHBAR(i,j,1);
			ITHBAR(i,j,NZ-1) = ITHBAR(i,j,NZ-2);
			IQBAR(i,j,0) = IQBAR(i,j,1);
			IQBAR(i,j,NZ-1) = IQBAR(i,j,NZ-2);
			IUBAR(i,j,0) = IUBAR(i,j,1);
			IUBAR(i,j,NZ-1) = IUBAR(i,j,NZ-2);
			IVBAR(i,j,0) = IVBAR(i,j,1);
			IVBAR(i,j,NZ-1) = IVBAR(i,j,NZ-2);
		}}

	//----------------------------------------------------------------
	// Initialize vertically varying, x,y independent basic state
	//----------------------------------------------------------------	
	initialize_vertical_basic_state(base_i,base_j);
	
	//----------------------------------------------------------------
	// Initialize topographic array
	//----------------------------------------------------------------
	//memset( &IISTOPO(0,0,0),1,NX*NY*NZ*sizeof(double));
	//memset(&IUISTOPO(0,0,0),1,NX*NY*NZ*sizeof(double));
	//memset(&IVISTOPO(0,0,0),1,NX*NY*NZ*sizeof(double));
	//memset(&htopo[0][0], 0,NX*NY*sizeof(int));

	/*

	for(int i=0;i<NX;i++){
	for(int j=0;j<NY;j++){
		HTOPO(i,j) = 1;
	}}
	*/
	for(int i=0;i<NX;i++){
	for(int j=0;j<NY;j++){
	for(int k=0;k<NZ;k++){
		//IISTOPO(i,j,k) = 1;
		//IUISTOPO(i,j,k) = 1;
		//IVISTOPO(i,j,k) = 1;
		ITOPO(i,j,k) = 0;
	}}}

	init_topography();

	double *zui;
	
	//----------------------------------------------------------------
	// Which coordinate system?
	//----------------------------------------------------------------
	if(!ISLINEAR)
		zui = &zsu[0];
	else
		zui = &zu[0];

	//----------------------------------------------------------------
	// Coriolis parameter
	//----------------------------------------------------------------
	for(int j=0;j<NY;j++){ 
		
		f[j] = 2*fc*sin(outLats[j]*trigpi/180.);
		dfdy[j] = 2*fc*cos(outLats[j]*trigpi/180.) * (1./meters_per_degree) * (trigpi/180.) ;
	}


	//----------------------------------------------------------------
	//
	// Create lower-level horizontal shear for basic state zonal wind
	//
	//----------------------------------------------------------------
	double ubar_max_lat = 25;
	double ubar_min_lat = 15;
	double ubar_north_lat = 28;
	double ubar_north_zero_lat = 35;
	double ubar_0 = 15;
	double ubar_1 = 8;
	double ubar_max_z = 7000;
	double ubar_max_lat_upper = 25;
	double ubar_min_lat_upper = 15;
	
	int ubar_max_y = get_point_from_lat(ubar_max_lat);
	int ubar_max_y_upper = get_point_from_lat(ubar_max_lat_upper);
	int ubar_min_y_upper = get_point_from_lat(ubar_min_lat_upper);
	int ubar_min_y = get_point_from_lat(ubar_min_lat);
	int ubar_north_y = get_point_from_lat(ubar_north_lat);
	int ubar_north_zero_y = get_point_from_lat(ubar_north_zero_lat);
	
	double ubar_north_slope = ubar_1 / (double)(ubar_north_zero_y - ubar_north_y);
	
	double zfrac = 0;
	
	double upper_profile[NY];
	
#if 1
	for(int i=0;i<NX;i++){
	for(int k=0;k<NZ;k++){
		
		if( zui[k] < ubar_max_z ){
		
			for(int j=0;j<ubar_min_y;j++){ IUBAR(i,j,k) = ubar_0; upper_profile[j] = ubar_0;}
		
			for(int j=ubar_min_y;j<ubar_max_y;j++){
			
				IUBAR(i,j,k) = IUBAR(i,j-1,k) - ((ubar_0+ubar_1) / (ubar_max_y - ubar_min_y))
					*(trigpi/2.0)*sin( trigpi*(j-ubar_min_y) / (ubar_max_y - ubar_min_y) )   ;
			
			}
			
			for(int j=ubar_min_y_upper;j<ubar_max_y_upper;j++){
			
				upper_profile[j] = upper_profile[j-1] - ((ubar_0+ubar_0) / (ubar_max_y_upper - ubar_min_y_upper))*
					(trigpi/2.0)*sin( trigpi*(j-ubar_min_y_upper) / (ubar_max_y_upper - ubar_min_y_upper) )   ;
			
			}
		
			for(int j=ubar_max_y;j<ubar_north_y;j++){ IUBAR(i,j,k) = -ubar_1;}
			
			for(int j=ubar_north_y;j<NY;j++){ IUBAR(i,j,k) = -ubar_1 + ubar_north_slope * (double)(j-ubar_north_y) ;}
		}
		//if(i==40 && k==10){ printf("%d %f\n",j,IUBAR(i,j,k));}
	}}
	
	for(int k=1;k<NZ;k++){
		
		zfrac = cos( ((zui[k]-2000) / (ubar_max_z-2000)) * 0.5*trigpi );
		
		for(int i=0;i<NX;i++){
		for(int j=0;j<NY;j++){
				
			if( zui[k] < ubar_max_z ){
				
				IUBAR(i,j,k) = IUBAR(i,j,0) * zfrac;
			
				
			} else if(j<base_j && zui[k]<12000){
				
				IUBAR(i,j,k) = upper_profile[j] * zfrac;
				
			} else if(zui[k]>12000 && j<base_j){
				
				IUBAR(i,j,k) = IUBAR(i,j,30);
			}

		}}

	}
	/*
	for(int k=1;k<NZ;k++){
		
		zfrac = cos( ((zui[k]-4000) / (ubar_max_z-0)) * 0.5*trigpi );
		
		for(int i=0;i<NX;i++){
		for(int j=0;j<NY;j++){
				
			if( zui[k] < ubar_max_z+4000 && j > base_j ){
				
				IUBAR(i,j,k) = IUBAR(i,j,0) * zfrac;
			
			} 

		}}

	}
	*/
	
	/*
	int i_min = NX/2;
	int i_max = NX/2+NX/4;
	double i_slope = 0.5;
	
	for(int i=i_min;i<i_max;i++){
	
		zfrac = i_slope + i_slope*(double)(i_max-i) / (double)(i_max - i_min);
		//printf("%f\n",zfrac);
		for(int k=0;k<NZ;k++){
		for(int j=0;j<NY;j++){	
		
			//if(zui[k] < ubar_max_z){
		
				IUBAR(i,j,k) *= zfrac;
				//}
		
		}}
	}
	
	for(int i=i_max;i<NX;i++){
	for(int k=0;k<NZ;k++){
	for(int j=0;j<NY;j++){	
		
		//if(zui[k] < ubar_max_z){
		
			IUBAR(i,j,k) = IUBAR(i_max-1,j,k);
			//}
		
	}}}
	
	*/

	
	
	//if(i==40 && j==NY/2-9){ printf("%d %f %f %f\n",k,zfrac,zui[k] / ubar_max_z,IUBAR(i,j,k));}
#endif
	//----------------------------------------------------------------
	//
	// Create upper-level baroclinic shear for basic state zonal wind
	//
	//----------------------------------------------------------------
#if 0

	double ubar_baroclinic_bot_z = 7000;//8000;
	double ubar_baroclinic_top_z = 16000;//18000;
	double ubar_baroclinic_top_ubar = -20;
	
	double slope;
	int klev;
	
	if(!ISLINEAR)
		klev = (int)convert_z_to_k(ubar_baroclinic_bot_z,50,1,dz);
	else
		klev = (int)(ubar_baroclinic_bot_z / dz + 0.001);
		
	for(int k=0;k<NZ;k++){
		
		if( zui[k] > ubar_baroclinic_bot_z && zui[k] < ubar_baroclinic_top_z ){
			
			for(int i=0;i<NX;i++){
			for(int j=0;j<NY;j++){
				
				slope = (ubar_baroclinic_top_ubar - IUBAR(i,j,klev)) / (ubar_baroclinic_top_z - ubar_baroclinic_bot_z);
				
				IUBAR(i,j,k) = IUBAR(i,j,k-1) + slope * (zui[k] - zui[k-1]) ;
				
				//if(i==40 && j==3){ printf("%d %f %f\n",k,slope,IUBAR(i,j,k));}
			}}
			
		} else if( zui[k] >= ubar_baroclinic_top_z) {
		
			for(int i=0;i<NX;i++){
			for(int j=0;j<NY;j++){
		
				IUBAR(i,j,k) = ubar_baroclinic_top_ubar;
			}}
			
		}

	}
#endif
	
	
	for(int i=0;i<NX;i++){
	for(int j=0;j<NY;j++){
	for(int k=0;k<NZ;k++){
		
		if(IUBAR(i,j,k) < -5){
			
			//UBAR(i,j,k) = -5;
		}
		
		if(zui[k] > 5000 && j > base_j){
			
			//IUBAR(i,j,k) = -5;
		}
		
	}}}
		

	
	for(int i=0;i<NX;i++){
	for(int j=0;j<NY;j++){
			
		IUBAR(i,j,0) = IUBAR(i,j,1);
	}}
	
	
	init_basic_state_meridional_velocity(base_j);
	
	
	/*
	//----------------------------------------------------------------
	// Remove model base state from environmental base state
	//----------------------------------------------------------------
	for(int i=0;i<NX;i++){
		for(int j=0;j<NY;j++){
			for(int k=0;k<NZ;k++){
				//ITHBAR(i,j,k) = ITHBAR(i,j,k) - tb[k];
				//IQBAR(i,j,k) = IQBAR(i,j,k) - qb[k];
			}
		}
	}
	*/
	

	for(int i=0;i<NX-1;i++){	
	for(int k=0;k<NZ;k++){
	
		for(int j=base_j-1;j>=1;j--){
		
			IPBAR(i,j,k) = IPBAR(i,j+1,k) + 0.25*(IUBAR(i,j-1,k)+IUBAR(i+1,j-1,k)+IUBAR(i,j,k)+IUBAR(i+1,j,k)) * dy *f[j];
			//if(i==NX/2 && (k==0 || k==1 || k==2)){
				//printf("%d %d %f %f\n",j,k,IPBAR(i,j,k),IUBAR(i,j,k));
			//}
		}
		//for(int j=2;j<NY;j++){		
		for(int j=base_j+1;j<NY;j++){
		
			IPBAR(i,j,k) = IPBAR(i,j-1,k) - 0.25*(IUBAR(i,j-1,k)+IUBAR(i+1,j-1,k)+IUBAR(i,j,k)+IUBAR(i+1,j,k)) * dy * f[j];
			//if(i==NX/2 && (k==0 || k==1 || k==2)){
				//printf("%d %d %f %f\n",j,k,IPBAR(i,j,k),IUBAR(i,j,k));
			//}
			
			//if(i==NX/2 && j == NY-3){
				//printf("%d %d %f %f %f\n",j,k,zui[k],IPBAR(i,j,k),IUBAR(i,j,k));
			//}
		}
	}}
	
	for(int i=0;i<NX;i++){			
	for(int j=0;j<NY;j++){
	for(int k=1;k<NZ-1;k++){

		ITHBAR(i,j,k) = tb[k]*(IPBAR(i,j,k-1) - IPBAR(i,j,k)) / (- grav * (zui[k]-zui[k-1]) );
		
	}}}
	
	
			
	//double store_temp[NZ];
	double store_pres[NZ];


	for(int k=0;k<NZ;k++){

		//store_temp[k] = ITHBAR(base_i,base_j,k);
		store_pres[k] =  IPBAR(base_i,base_j,k);

	}

	
	for(int i=0;i<NX;i++){
	for(int j=0;j<NY;j++){
	for(int k=0;k<NZ;k++){

		IPBAR(i,j,k) =  (IPBAR(i,j,k) - store_pres[k]) / (cp*tbv[k]) + full_base_pres[k];
		//ITHBAR(i,j,k) -= store_temp[k];

	}}}
	
	
	for(int i=0;i<NX;i++){
	for(int j=0;j<NY;j++){
			
		for(int k=NZ-2;k>0;k--){
			
			if( ITHBAR(i,j,k) + tb[k] > ITHBAR(i,j,k+1) + tb[k+1] ){
				//printf("%d %d %d %f %f\n",i,j,k,ITHBAR(i,j,k) + tb[k],ITHBAR(i,j,k+1) + tb[k+1]);
				ITHBAR(i,j,k) = ITHBAR(i,j,k+1) + tb[k+1] - tb[k] - 0.1;
				//printf("%d %d %d %f %f\n",i,j,k,ITHBAR(i,j,k) + tb[k],ITHBAR(i,j,k+1) + tb[k+1]);
			}
			
		}
			
	}}
	
	int south_thbar = get_point_from_lat(8);
	//int south_thbar = get_point_from_lat(21);
	
	for(int i=0;i<NX;i++){
	for(int j=0;j<south_thbar;j++){			
	for(int k=0;k<NZ;k++){
		
		ITHBAR(i,j,k) = ITHBAR(i,south_thbar,k);
		
	}}}
			
	
	
	for(int i=0;i<NX;i++){
		for(int j=0;j<NY;j++){
			
			ITHBAR(i,j,2) = ITHBAR(i,j,3);
			ITHBAR(i,j,1) = ITHBAR(i,j,2);
			ITHBAR(i,j,0) = ITHBAR(i,j,1);
	}}
	
	for(int i=0;i<NX;i++){
	for(int k=0;k<NZ;k++){
			
		ITHBAR(i,0,k) = ITHBAR(i,1,k);
	}}
	/*
	for(int i=0;i<NX;i++){
	for(int j=0;j<NY;j++){			
	for(int k=0;k<NZ;k++){
		
		if(IUBAR(i,j,k) > 0){
		
			IUBAR(i,j,k) = 0.0;
		}
	}}}
*/
	
	double smr,temp,pres,rh;
	double base_temp[NZ];
	double base_pres[NZ];
	double base_relh[NZ];
	
	//-----------------------------------------------------------------------
	// Relative humidity changes
	//-----------------------------------------------------------------------
	int rh_y_min = get_point_from_lat(5);
	int rh_y_max = get_point_from_lat(14);
	int rh_y_min2 = get_point_from_lat(30);
	int rh_y_max2 = get_point_from_lat(36);
	
	double rh_decrease = 0.2;
	double rh_decrease2 = 0.3;
	double rh_drop[NY];
	double rh_slope = rh_decrease / (double)(rh_y_max-rh_y_min);
	double rh_slope2 = rh_decrease2 / (double)(rh_y_min2-rh_y_max2);
	
	for(int j=NY;j>rh_y_max;j--){			rh_drop[j] = 0;							}
	
	for(int j=rh_y_max;j>rh_y_min;j--){		rh_drop[j] = rh_drop[j+1] + rh_slope;	}
	
	for(int j=rh_y_min;j>=0;j--){			rh_drop[j] = rh_decrease;				}

	for(int j=rh_y_min2;j<rh_y_max2;j++){	rh_drop[j] = rh_drop[j-1] - rh_slope2;	}
	
	for(int j=rh_y_max2;j<NY;j++){			rh_drop[j] = rh_decrease2;				}

	//-----------------------------------------------------------------------
	// Calculate mixing ratio
	//-----------------------------------------------------------------------	
	for(int k=0;k<NZ;k++){
		
		base_temp[k] = tb[k]*pib[k];
		base_pres[k] = p0*pow(pib[k],(cp/Rd));
		
		base_relh[k] = qb[k] / get_QV_Sat(base_temp[k],base_pres[k]);
	}


	for(int i=0;i<NX;i++){
	for(int j=0;j<NY;j++){
	for(int k=1;k<NZ-1;k++){

		temp = (ITHBAR(i,j,k)+tb[k]) * IPBAR(i,j,k);	// full, actual temperature
		pres = p0*pow(IPBAR(i,j,k),(cp/Rd));			// full, dimensional pressure

		smr = get_QV_Sat(temp,pres);					// calculate saturation mixing ratio

		IQBAR(i,j,k) = (base_relh[k]-rh_drop[j]) * smr - qb[k];

		if(i==NX/2 && k==NZ-1){ printf("%d %d %f %f %f %f %f %f\n",j,k,outLats[j],pres/100.0,base_relh[k],qb[k]*1000,smr*1000,IQBAR(i,j,k)*1000);}		
		//if(i==NX/2 && j==NY/4){ printf("%d %f %f %f %f %f %f\n",k,zui[k],pres/100.0,base_relh[k],qb[k]*1000,smr*1000,IQBAR(i,j,k)*1000);}
	
	}}}

	for(int i=0;i<NX;i++){
	for(int j=0;j<NY;j++){

		IQBAR(i,j,0) = IQBAR(i,j,1);
		IQBAR(i,j,NZ-1) = IQBAR(i,j,NZ-2);
	}}

	for(int i=0;i<NX;i++){
	for(int j=0;j<NY;j++){
	for(int k=0;k<NZ;k++){
		
		IUBAR(i,j,k) -= 5.0;
		
	}}}



	//----------------------------------------------------------------
	// Initialize friction array
	//----------------------------------------------------------------
	init_friction();

	//----------------------------------------------------------------
	// Calculate base state vertical velocity
	//----------------------------------------------------------------
	init_basic_state_vertical_velocity();




}
#endif


#if 0

	double midLat = 21;
	int mid_lat = get_point_from_lat(midLat);
	
	//----------------------------------------------------------------
	// Defines length and width of shear zone
	//----------------------------------------------------------------
	int low_lat = get_point_from_lat(18);
	int high_lat = get_point_from_lat(28);
	int low_lon = get_point_from_lon(67);
	int high_lon = get_point_from_lon(100);
	int high_lev = 28;
	int low_lev = 0;
	int width = (int)(5.0 * 111000 / dy);	// half-width in grid points

	//----------------------------------------------------------------
	// Defines axis of monsoon trough from 
	// xpoint1,ypoint1 to xpoint2,ypoint2
	//----------------------------------------------------------------
	//int ypoint1 = get_point_from_lat(30-4);
	int ypoint1 = get_point_from_lat(23);
	int xpoint1 = low_lon;//get_point_from_lon(60);
	int ypoint2 = get_point_from_lat(16);
	int xpoint2 = high_lon;//get_point_from_lon(120);

	//ypoint1 = get_point_from_lat(20);
	//ypoint2 = get_point_from_lat(20);
	
	int * line = (int *)calloc(NX,sizeof(int));
	
	line_array(xpoint1,ypoint1,xpoint2,ypoint2,line);
	
	double mult = 1.0;
	double d = 38;
	double s = 1.0;
	int fi = 0;
	
	int top_vort = 64;//76;//64;
	
	//for(int i=0;i<100;i++){ printf("%d %f\n",i,cos_profile(-0.25,0.5,(double)i/100,1));}
	//exit(0);
	
	int rotate_lat = 0;
	
	printf("coords ranges = %d %d %d %d\n",low_lat,high_lat,low_lon,high_lon);
	for(int i=low_lon;i<high_lon;i++){
	for(int j=line[i]-width;j<line[i]+width;j++){
		
		//rotate_lat = line[i];
		
		//low_lat = line[i];
		//printf("%d %d\n",i,low_lat);
		for(int k=0;k<top_vort;k++){

			
			mult = 0.3*cos_profile(-0.15,0.5,(double)k/(double)top_vort,1.0) * 
				       cos_profile(-0.2,0.2,(double)(i-low_lon)/(double)(high_lon-low_lon),0) *
					   cos_profile(-0.25,0.25,(double)(j-line[i]+width)/(double)(2*width),0);
						   
						   ;
			//if(i==NX/2 && k==3){			   
			//printf("%d %f\n",j,cos_profile(-0.25,0.25,(double)(j-line[i]+width)/(double)(2*width),0));
			//}		   
			IVORT(i,j,k) = 6.0e-5 * mult;//2*3.5e-5 * mult;			   
		}
	}}
	
	
	
	for(int i=low_lon;i<high_lon;i++){
	for(int j=line[i]+width;j<line[i]+width+5;j++){
		

		for(int k=0;k<top_vort;k++){

			
			mult = 0.3*cos_profile(-0.1,0.5,(double)k/(double)top_vort,1.0) * 
				       cos_profile(-0.2,0.2,(double)(i-low_lon)/(double)(high_lon-low_lon),0) *
					   cos_profile(-0.25,0.25,(double)(j-line[i]-width)/(double)(5),0);
						   
						   ;
	   
			IVORT(i,j,k) = -4.0e-5 * mult;//-2*2.5e-5 * mult;			   
		}
	}}
	
#endif
